{% extends "app/base.html" %}

{% from "macros/index_page/header.html" import render_header %}
{% from "macros/index_page/drawer.html" import render_drawer %}
{% from "macros/index_page/footer.html" import render_footer %}
{% from "macros/index_page/hero.html" import render_hero %}

{% block header %}
{{ render_header() }}
{% endblock %}

{% block content %}
<!-- Drawer -->
{{ render_drawer() }}

<!-- Main content -->
<div id="main-content" class="w-full">
  {{ render_hero() }}
  
  <!-- New Section: GSAP + WebGL Image Flow -->
  <section id="image-flow" class="relative w-full h-screen overflow-hidden bg-slate-900">
    <!-- Canvas for Three.js -->
    <canvas id="flow-canvas" class="absolute inset-0 w-full h-full"></canvas>
    
    <!-- Overlay text (optional) -->
    <div class="absolute inset-0 flex items-center justify-center pointer-events-none z-10">
      <h2 class="font-['Playfair_Display'] text-4xl md:text-6xl text-white/20 font-black tracking-wider">
        FLUID MOTION
      </h2>
    </div>
  </section>
</div>

{{ render_footer() }}
{% endblock %}

{% block scripts %}
<!-- Vanilla JS for drawer toggling (unchanged) -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('drawerOverlay');
    const closeBtn = document.getElementById('closeDrawerBtn');
    const drawerLinks = drawer ? drawer.querySelectorAll('a') : [];
    
    function openDrawer() {
      if (drawer) {
        drawer.classList.remove('-translate-x-full');
        overlay.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        
        const spans = hamburgerBtn?.querySelectorAll('span');
        if (spans && spans.length === 3) {
          spans[0].style.transform = 'rotate(45deg) translateY(9px)';
          spans[1].style.opacity = '0';
          spans[2].style.transform = 'rotate(-45deg) translateY(-9px)';
        }
      }
    }
    
    function closeDrawer() {
      if (drawer) {
        drawer.classList.add('-translate-x-full');
        overlay.classList.add('hidden');
        document.body.style.overflow = '';
        
        const spans = hamburgerBtn?.querySelectorAll('span');
        if (spans && spans.length === 3) {
          spans[0].style.transform = 'rotate(0) translateY(0)';
          spans[1].style.opacity = '1';
          spans[2].style.transform = 'rotate(0) translateY(0)';
        }
      }
    }
    
    if (hamburgerBtn) hamburgerBtn.addEventListener('click', openDrawer);
    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if (overlay) overlay.addEventListener('click', closeDrawer);
    
    drawerLinks.forEach(link => link.addEventListener('click', closeDrawer));
    
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && drawer && !drawer.classList.contains('-translate-x-full')) {
        closeDrawer();
      }
    });
  });
</script>

<!-- GSAP + Three.js Image Flow -->
<script>
  (function() {
    // Wait for DOM and ensure Three.js is loaded
    if (typeof THREE === 'undefined' || typeof gsap === 'undefined') return;
    
    // --- Setup Scene, Camera, Renderer ---
    const canvas = document.getElementById('flow-canvas');
    if (!canvas) return;
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a192f); // dark blue-black
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 15);
    
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // --- Create a grid of 20 "image planes" (using colored boxes for simplicity) ---
    const group = new THREE.Group();
    const colors = [0x4f6d7a, 0x9e7b9b, 0x7a9e7e, 0xb85e5e, 0xe6b89c];
    const geometry = new THREE.BoxGeometry(1.2, 1.6, 0.1); // simulate image proportions
    
    for (let i = 0; i < 20; i++) {
      const material = new THREE.MeshStandardMaterial({
        color: colors[i % colors.length],
        emissive: 0x222222,
        roughness: 0.3,
        metalness: 0.1
      });
      const cube = new THREE.Mesh(geometry, material);
      
      // Position in a grid (5 columns, 4 rows) with some randomness
      const col = i % 5;
      const row = Math.floor(i / 5);
      cube.position.x = (col - 2) * 2.5 + (Math.random() - 0.5) * 0.5;
      cube.position.y = (row - 1.5) * 2.2 + (Math.random() - 0.5) * 0.5;
      cube.position.z = (Math.random() - 0.5) * 2;
      
      // Random rotation
      cube.rotation.x = (Math.random() - 0.5) * 0.5;
      cube.rotation.y = (Math.random() - 0.5) * 0.5;
      
      group.add(cube);
    }
    scene.add(group);
    
    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0x404060);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(1, 2, 5);
    scene.add(dirLight);
    
    const backLight = new THREE.PointLight(0x446688, 0.5);
    backLight.position.set(-2, 1, -3);
    scene.add(backLight);
    
    // --- GSAP Timeline with Staggers ---
    const tl = gsap.timeline({ repeat: -1, yoyo: true, ease: "power2.inOut" });
    
    // Stagger each cube's rotation and position
    tl.to(group.children, {
        duration: 2,
        stagger: {
          each: 0.1,
          from: "center",
          grid: "auto",
          ease: "sine.inOut"
        },
        rotationY: "+=6.28", // full rotation
        rotationX: "+=1.57",
        y: "+=0.5",
        z: "+=1",
        ease: "power1.inOut"
      }, 0)
      .to(group.children, {
        duration: 2,
        stagger: {
          each: 0.1,
          from: "edges",
          ease: "sine.inOut"
        },
        rotationY: "-=3.14",
        rotationX: "-=1.0",
        y: "-=0.5",
        z: "-=1",
        ease: "power1.inOut"
      }, 2);
    
    // Also animate the whole group slowly
    gsap.to(group.rotation, {
      y: "+=6.28",
      duration: 20,
      repeat: -1,
      ease: "none"
    });
    
    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
    
    // --- Handle Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
  })();
</script>
{% endblock %}