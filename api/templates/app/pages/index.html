{% extends "app/base.html" %}

{% from "macros/index_page/header.html" import render_header %}
{% from "macros/index_page/drawer.html" import render_drawer %}
{% from "macros/index_page/footer.html" import render_footer %}
{% from "macros/index_page/hero.html" import render_hero %}

{% block header %}
{{ render_header() }}
{% endblock %}

{% block content %}
<!-- Drawer -->
{{ render_drawer() }}

<!-- Main content -->
<div id="main-content" class="w-full">
  {{ render_hero() }}
  
  <!-- New Section: Stacked Image Flow with Scroll -->
  <section id="image-flow" class="relative w-full h-[200vh] bg-slate-900">
    <div class="sticky top-0 h-screen overflow-hidden">
      <canvas id="flow-canvas" class="absolute inset-0 w-full h-full"></canvas>
      
      <!-- Overlay text (bottom) -->
      <div class="absolute bottom-10 left-1/2 -translate-x-1/2 z-10 text-white/40 text-xl font-light tracking-widest">
        FLUID MOTION
      </div>
    </div>
  </section>
</div>

{{ render_footer() }}
{% endblock %}

{% block scripts %}
<!-- Vanilla JS for drawer toggling (unchanged) -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('drawerOverlay');
    const closeBtn = document.getElementById('closeDrawerBtn');
    const drawerLinks = drawer ? drawer.querySelectorAll('a') : [];
    
    function openDrawer() {
      if (drawer) {
        drawer.classList.remove('-translate-x-full');
        overlay.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        
        const spans = hamburgerBtn?.querySelectorAll('span');
        if (spans && spans.length === 3) {
          spans[0].style.transform = 'rotate(45deg) translateY(9px)';
          spans[1].style.opacity = '0';
          spans[2].style.transform = 'rotate(-45deg) translateY(-9px)';
        }
      }
    }
    
    function closeDrawer() {
      if (drawer) {
        drawer.classList.add('-translate-x-full');
        overlay.classList.add('hidden');
        document.body.style.overflow = '';
        
        const spans = hamburgerBtn?.querySelectorAll('span');
        if (spans && spans.length === 3) {
          spans[0].style.transform = 'rotate(0) translateY(0)';
          spans[1].style.opacity = '1';
          spans[2].style.transform = 'rotate(0) translateY(0)';
        }
      }
    }
    
    if (hamburgerBtn) hamburgerBtn.addEventListener('click', openDrawer);
    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if (overlay) overlay.addEventListener('click', closeDrawer);
    
    drawerLinks.forEach(link => link.addEventListener('click', closeDrawer));
    
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && drawer && !drawer.classList.contains('-translate-x-full')) {
        closeDrawer();
      }
    });
  });
</script>

<!-- GSAP + Three.js Stacked Image Flow -->
<script>
  (function() {
    if (typeof THREE === 'undefined' || typeof gsap === 'undefined') return;
    
    const canvas = document.getElementById('flow-canvas');
    if (!canvas) return;
    
    // --- Setup Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a192f);
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 12);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // --- Lighting ---
    const ambient = new THREE.AmbientLight(0x404060);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(2, 5, 5);
    scene.add(dirLight);
    const backLight = new THREE.PointLight(0x336699, 0.5);
    backLight.position.set(-2, 1, -3);
    scene.add(backLight);
    
    // --- Create Stack of Image Planes ---
    const group = new THREE.Group();
    const imageCount = 8;
    const imageUrls = [
      'https://images.unsplash.com/photo-1618220179428-22790b461013?w=400&q=80', // bath
      'https://images.unsplash.com/photo-1618219944342-824e40a1328e?w=400&q=80', // ceramic
      'https://images.unsplash.com/photo-1584622650111-993a426fbf0a?w=400&q=80', // water
      'https://images.unsplash.com/photo-1600566753086-00f18fb6b3ea?w=400&q=80', // architecture
      'https://images.unsplash.com/photo-1616486338812-3dadae4b4ace?w=400&q=80', // interior
      'https://images.unsplash.com/photo-1616046229478-9901c5536a45?w=400&q=80', // spa
      'https://images.unsplash.com/photo-1604014237800-1c9102c219da?w=400&q=80', // luxury
      'https://images.unsplash.com/photo-1600566753190-17f0baa2a6c3?w=400&q=80' // stone
    ];
    
    // Geometry: plane with aspect ratio 3:4 (portrait)
    const geometry = new THREE.PlaneGeometry(2, 2.67);
    
    imageUrls.forEach((url, index) => {
      const texture = new THREE.TextureLoader().load(url);
      const material = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.DoubleSide,
        emissive: 0x000000,
        roughness: 0.3,
        metalness: 0.1
      });
      const plane = new THREE.Mesh(geometry, material);
      
      // Stack vertically with offset: each image slightly above previous, and shifted back in Z
      const yOffset = index * 0.6;
      const zOffset = -index * 0.8;
      plane.position.set(0, yOffset, zOffset);
      
      // Slight random rotation for organic feel
      plane.rotation.x = (Math.random() - 0.5) * 0.1;
      plane.rotation.y = (Math.random() - 0.5) * 0.1;
      
      // Store index for hover effects
      plane.userData = { index, baseY: yOffset, baseZ: zOffset };
      
      group.add(plane);
    });
    
    scene.add(group);
    
    // --- ScrollTrigger Animation ---
    gsap.registerPlugin(ScrollTrigger);
    
    ScrollTrigger.create({
      trigger: "#image-flow",
      start: "top top",
      end: "bottom bottom",
      scrub: 1.5,
      onUpdate: (self) => {
        const progress = self.progress;
        group.rotation.y = progress * 0.8;
        camera.position.x = progress * 2;
        camera.position.y = 2 + progress * 1.5;
        camera.lookAt(0, 2, 0);
      }
    });
    
    // Spread individual planes on scroll
    gsap.to(group.children, {
      scrollTrigger: {
        trigger: "#image-flow",
        start: "top top",
        end: "bottom bottom",
        scrub: 1
      },
      z: (i) => i * -1.2,
      y: (i) => i * 0.8,
      ease: "power1.inOut",
      stagger: 0.02
    });
    
    // --- Hover Effect (blue tint) ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredPlane = null;
    
    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(group.children);
      
      if (intersects.length > 0) {
        const hit = intersects[0].object;
        if (hoveredPlane !== hit) {
          if (hoveredPlane) {
            hoveredPlane.material.emissive.setHex(0x000000);
            hoveredPlane.scale.set(1, 1, 1);
          }
          hoveredPlane = hit;
          hoveredPlane.material.emissive.setHex(0x224466);
          hoveredPlane.scale.set(1.05, 1.05, 1.05);
        }
      } else {
        if (hoveredPlane) {
          hoveredPlane.material.emissive.setHex(0x000000);
          hoveredPlane.scale.set(1, 1, 1);
          hoveredPlane = null;
        }
      }
    });
    
    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
    
    // --- Resize Handler ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
  })();
</script>
{% endblock %}