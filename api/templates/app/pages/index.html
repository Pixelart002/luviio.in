{% extends "app/base.html" %}

{% from "macros/index_page/header.html" import render_header %}
{% from "macros/index_page/drawer.html" import render_drawer %}
{% from "macros/index_page/footer.html" import render_footer %}
{% from "macros/index_page/hero.html" import render_hero %}

{% block header %}
{{ render_header() }}
{% endblock %}

{% block content %}
<!-- Drawer -->
{{ render_drawer() }}

<!-- Main content -->
<div id="main-content" class="w-full">
  {{ render_hero() }}
  
  <!-- SECTION 1: STACKED IMAGE FLOW (WebGL + Scroll) -->
  <section id="image-flow" class="relative w-full h-[200vh] bg-slate-900">
    <div class="sticky top-0 h-screen overflow-hidden">
      <canvas id="flow-canvas" class="absolute inset-0 w-full h-full"></canvas>
      <!-- Overlay text at bottom -->
      <div class="absolute bottom-10 left-1/2 -translate-x-1/2 z-10 text-white/40 text-xl font-light tracking-widest">
        FLUID MOTION
      </div>
    </div>
  </section>

  <!-- SECTION 2: POP-IN CARD LOOP (GSAP) -->
  <section id="popin-demo" class="relative w-full min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 py-20 overflow-hidden">
    <div class="max-w-7xl mx-auto px-6 text-center mb-12">
      <h2 class="font-['Playfair_Display'] text-4xl md:text-5xl text-white mb-4">Infinite Loop</h2>
      <p class="text-slate-300 text-lg">Images pop in from below, old ones minimize â€“ a continuous dance.</p>
    </div>

    <div class="relative h-[500px] w-full max-w-4xl mx-auto perspective">
      <!-- Card container (populated by JS) -->
      <div id="popin-cards" class="relative w-full h-full flex items-center justify-center"></div>
    </div>
  </section>
</div>

{{ render_footer() }}
{% endblock %}

{% block scripts %}
<!-- Vanilla JS for drawer toggling -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('drawerOverlay');
    const closeBtn = document.getElementById('closeDrawerBtn');
    const drawerLinks = drawer ? drawer.querySelectorAll('a') : [];
    
    function openDrawer() {
      if (drawer) {
        drawer.classList.remove('-translate-x-full');
        overlay.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        
        const spans = hamburgerBtn?.querySelectorAll('span');
        if (spans && spans.length === 3) {
          spans[0].style.transform = 'rotate(45deg) translateY(9px)';
          spans[1].style.opacity = '0';
          spans[2].style.transform = 'rotate(-45deg) translateY(-9px)';
        }
      }
    }
    
    function closeDrawer() {
      if (drawer) {
        drawer.classList.add('-translate-x-full');
        overlay.classList.add('hidden');
        document.body.style.overflow = '';
        
        const spans = hamburgerBtn?.querySelectorAll('span');
        if (spans && spans.length === 3) {
          spans[0].style.transform = 'rotate(0) translateY(0)';
          spans[1].style.opacity = '1';
          spans[2].style.transform = 'rotate(0) translateY(0)';
        }
      }
    }
    
    if (hamburgerBtn) hamburgerBtn.addEventListener('click', openDrawer);
    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if (overlay) overlay.addEventListener('click', closeDrawer);
    
    drawerLinks.forEach(link => link.addEventListener('click', closeDrawer));
    
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && drawer && !drawer.classList.contains('-translate-x-full')) {
        closeDrawer();
      }
    });
  });
</script>

<!-- GSAP + Three.js Stacked Image Flow (with images, hover, scroll) -->
<script>
  (function() {
    if (typeof THREE === 'undefined' || typeof gsap === 'undefined') return;

    const canvas = document.getElementById('flow-canvas');
    if (!canvas) return;

    // --- Setup Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a192f);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 12);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // --- Lighting ---
    const ambient = new THREE.AmbientLight(0x404060);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(2, 5, 5);
    scene.add(dirLight);
    const backLight = new THREE.PointLight(0x336699, 0.5);
    backLight.position.set(-2, 1, -3);
    scene.add(backLight);

    // --- Create Stack of Image Planes ---
    const group = new THREE.Group();
    const imageUrls = [
      'https://images.unsplash.com/photo-1618220179428-22790b461013?w=400&q=80',
      'https://images.unsplash.com/photo-1618219944342-824e40a1328e?w=400&q=80',
      'https://images.unsplash.com/photo-1584622650111-993a426fbf0a?w=400&q=80',
      'https://images.unsplash.com/photo-1600566753086-00f18fb6b3ea?w=400&q=80',
      'https://images.unsplash.com/photo-1616486338812-3dadae4b4ace?w=400&q=80',
      'https://images.unsplash.com/photo-1616046229478-9901c5536a45?w=400&q=80',
      'https://images.unsplash.com/photo-1604014237800-1c9102c219da?w=400&q=80',
      'https://images.unsplash.com/photo-1600566753190-17f0baa2a6c3?w=400&q=80'
    ];

    const geometry = new THREE.PlaneGeometry(2, 2.67); // 3:4 portrait

    imageUrls.forEach((url, index) => {
      const texture = new THREE.TextureLoader().load(url);
      const material = new THREE.MeshStandardMaterial({ 
        map: texture,
        side: THREE.DoubleSide,
        emissive: 0x000000,
        roughness: 0.3,
        metalness: 0.1
      });
      const plane = new THREE.Mesh(geometry, material);

      // Stack vertically with offset
      const yOffset = index * 0.6;
      const zOffset = -index * 0.8;
      plane.position.set(0, yOffset, zOffset);
      
      // Slight random rotation
      plane.rotation.x = (Math.random() - 0.5) * 0.1;
      plane.rotation.y = (Math.random() - 0.5) * 0.1;

      plane.userData = { index, baseY: yOffset, baseZ: zOffset };
      group.add(plane);
    });

    scene.add(group);

    // --- ScrollTrigger Animation ---
    gsap.registerPlugin(ScrollTrigger);

    ScrollTrigger.create({
      trigger: "#image-flow",
      start: "top top",
      end: "bottom bottom",
      scrub: 1.5,
      onUpdate: (self) => {
        const progress = self.progress;
        group.rotation.y = progress * 0.8;
        camera.position.x = progress * 2;
        camera.position.y = 2 + progress * 1.5;
        camera.lookAt(0, 2, 0);
      }
    });

    // Spread individual planes on scroll
    gsap.to(group.children, {
      scrollTrigger: {
        trigger: "#image-flow",
        start: "top top",
        end: "bottom bottom",
        scrub: 1
      },
      z: (i) => i * -1.2,
      y: (i) => i * 0.8,
      ease: "power1.inOut",
      stagger: 0.02
    });

    // --- Hover Effect (blue tint) ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredPlane = null;

    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(group.children);

      if (intersects.length > 0) {
        const hit = intersects[0].object;
        if (hoveredPlane !== hit) {
          if (hoveredPlane) {
            hoveredPlane.material.emissive.setHex(0x000000);
            hoveredPlane.scale.set(1, 1, 1);
          }
          hoveredPlane = hit;
          hoveredPlane.material.emissive.setHex(0x224466);
          hoveredPlane.scale.set(1.05, 1.05, 1.05);
        }
      } else {
        if (hoveredPlane) {
          hoveredPlane.material.emissive.setHex(0x000000);
          hoveredPlane.scale.set(1, 1, 1);
          hoveredPlane = null;
        }
      }
    });

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // --- Resize Handler ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  })();
</script>

<!-- GSAP Pop-in Card Loop -->
<script>
  (function() {
    if (typeof gsap === 'undefined') return;

    const container = document.getElementById('popin-cards');
    if (!container) return;

    container.innerHTML = '';

    const images = [
      'https://images.unsplash.com/photo-1618220179428-22790b461013?w=400&q=80',
      'https://images.unsplash.com/photo-1618219944342-824e40a1328e?w=400&q=80',
      'https://images.unsplash.com/photo-1584622650111-993a426fbf0a?w=400&q=80',
      'https://images.unsplash.com/photo-1600566753086-00f18fb6b3ea?w=400&q=80',
      'https://images.unsplash.com/photo-1616486338812-3dadae4b4ace?w=400&q=80'
    ];

    const cards = [];
    images.forEach((src, index) => {
      const card = document.createElement('div');
      card.className = 'absolute w-64 h-80 rounded-2xl overflow-hidden shadow-2xl transition-all duration-300';
      card.style.background = `url(${src}) center/cover`;
      card.style.boxShadow = '0 20px 40px rgba(0,0,0,0.5)';
      card.style.border = '2px solid rgba(255,255,255,0.1)';
      card.style.backfaceVisibility = 'hidden';
      
      const depth = index * 0.15;
      const scale = 1 - depth * 0.3;
      const yOffset = index * 15;
      const widthFactor = 1 - depth * 0.2;

      gsap.set(card, {
        scale: scale,
        y: yOffset,
        zIndex: 100 - index,
        width: 16 * widthFactor + 'rem',
        opacity: 1 - index * 0.1,
        filter: `blur(${index * 0.5}px)`
      });

      container.appendChild(card);
      cards.push(card);
    });

    function startLoop() {
      const tl = gsap.timeline({ repeat: -1, repeatDelay: 0.5, ease: "power2.inOut" });

      const currentScales = cards.map(c => gsap.getProperty(c, 'scale'));
      const currentY = cards.map(c => gsap.getProperty(c, 'y'));
      const currentWidth = cards.map(c => parseFloat(c.style.width) || 16);
      const currentZ = cards.map(c => parseInt(c.style.zIndex) || 0);
      const currentOpacity = cards.map(c => gsap.getProperty(c, 'opacity'));
      const currentBlur = cards.map(c => parseFloat(c.style.filter.replace(/[^\d.]/g, '')) || 0);

      const targetScales = [currentScales[cards.length-1], ...currentScales.slice(0, -1)];
      const targetY = [currentY[cards.length-1] - 15 * (cards.length-1), ...currentY.slice(0, -1)];
      const targetWidth = [currentWidth[cards.length-1] * 1.2, ...currentWidth.slice(0, -1)];
      const targetZ = [100, ...currentZ.slice(0, -1).map(z => z - 10)];
      const targetOpacity = [1, ...currentOpacity.slice(0, -1).map(o => o - 0.1)];
      const targetBlur = [0, ...currentBlur.slice(0, -1).map(b => b + 0.5)];

      cards.forEach((card, i) => {
        tl.to(card, {
          scale: targetScales[i],
          y: targetY[i],
          width: targetWidth[i] + 'rem',
          zIndex: targetZ[i],
          opacity: targetOpacity[i],
          filter: `blur(${targetBlur[i]}px)`,
          duration: 1,
          ease: "power2.inOut"
        }, 0);
      });

      tl.fromTo(cards[cards.length-1], 
        { scale: targetScales[0] * 0.8, y: targetY[0] + 50, opacity: 0.5 },
        { scale: targetScales[0], y: targetY[0], opacity: 1, duration: 0.8, ease: "back.out(1.7)" },
        0.2
      );
    }

    setTimeout(startLoop, 500);
  })();
</script>
{% endblock %}