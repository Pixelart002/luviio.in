{% extends "app/base.html" %}

{% from "macros/index_page/header.html" import render_header %}
{% from "macros/index_page/drawer.html" import render_drawer %}
{% from "macros/index_page/footer.html" import render_footer %}
{% from "macros/index_page/hero.html" import render_hero %}

{% block header %}
{{ render_header() }}
{% endblock %}

{% block content %}
<!-- Drawer -->
{{ render_drawer() }}

<!-- Main content -->
<div id="main-content" class="w-full">
  {{ render_hero() }}

  <!-- SECTION 1: GSAP STAGGER GRID (3D CARD FLIP) -->
  <section class="relative w-full min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 py-24 perspective overflow-hidden">
    <div class="max-w-7xl mx-auto px-6 text-center mb-20">
      <h2 class="font-['Playfair_Display'] text-6xl md:text-7xl text-white mb-4">
        GSAP <span class="text-teal-400">STAGGER</span>
      </h2>
      <p class="text-slate-300 text-xl">Advanced 3D flip with custom stagger patterns</p>
    </div>

    <!-- Stagger Grid - 3x3 Cards -->
    <div class="grid grid-cols-2 md:grid-cols-3 gap-4 md:gap-6 max-w-6xl mx-auto px-6" id="stagger-grid">
      <!-- Cards populated by JS -->
    </div>
  </section>

  <!-- SECTION 2: GSAP HORIZONTAL SCROLL GALLERY -->
  <section id="horizontal-scroll-section" class="relative w-full h-screen bg-slate-900 overflow-hidden">
    <div class="sticky top-0 h-screen flex items-center overflow-hidden">
      <div id="horizontal-track" class="flex gap-4 md:gap-8 px-4 md:px-16 will-change-transform">
        <!-- Cards inserted by JS -->
      </div>
    </div>
  </section>

  <!-- SECTION 3: DITHER SHADER (ACETERNITY ASCII STYLE) -->
  <section class="relative w-full min-h-screen bg-black py-24 overflow-hidden">
    <div class="max-w-7xl mx-auto px-6 text-center mb-12 relative z-10">
      <h2 class="font-['Playfair_Display'] text-5xl md:text-6xl text-white mb-4">
        Dither <span class="text-teal-400">Shader</span>
      </h2>
      <p class="text-slate-300 text-lg">Move mouse to interact | Configurable modes & colors</p>
    </div>

    <!-- Container for dither shader canvas + controls (optional) -->
    <div class="relative w-full max-w-5xl mx-auto px-6">
      <div class="relative overflow-hidden rounded-2xl border border-neutral-800 bg-neutral-950">
        <canvas id="dither-canvas" class="w-full h-auto aspect-[16/9]"></canvas>
      </div>
      <!-- Simple controls (you can remove or expand) -->
      <div class="mt-6 flex flex-wrap gap-4 justify-center text-white text-sm">
        <label><input type="radio" name="ditherMode" value="bayer" checked> Bayer</label>
        <label><input type="radio" name="ditherMode" value="halftone"> Halftone</label>
        <label><input type="radio" name="ditherMode" value="noise"> Noise</label>
        <label><input type="radio" name="ditherMode" value="crosshatch"> Crosshatch</label>
        <label class="ml-4"><input type="checkbox" id="animatedCheck" checked> Animate</label>
      </div>
    </div>
  </section>
</div>

{{ render_footer() }}
{% endblock %}

{% block scripts %}
<!-- Vanilla JS for drawer toggling (unchanged) -->
<script>
  // ... (your existing drawer script) ...
</script>

<!-- Active Navigation Script (unchanged) -->
<script>
  // ... (your existing nav script) ...
</script>

<!-- GSAP + Dither Shader -->
<script>
  (function() {
    if (typeof gsap === 'undefined') return;
    gsap.registerPlugin(ScrollTrigger);

    const isMobile = window.innerWidth < 768;

    // --- GSAP STAGGER GRID (same as before, with responsive timing) ---
    // ... (your existing stagger grid code) ...

    // --- GSAP HORIZONTAL SCROLL GALLERY (same as before) ---
    // ... (your existing horizontal scroll code) ...

    // --- 3. DITHER SHADER (standalone JS version) ---
    (function initDither() {
      const canvas = document.getElementById('dither-canvas');
      if (!canvas) return;

      // --- Configuration (matching React component props) ---
      const config = {
        src: 'https://images.unsplash.com/photo-1493246507139-91e8fad9978e?q=80&w=2670&auto=format&fit=crop',
        gridSize: 4,
        ditherMode: 'bayer',      // 'bayer', 'halftone', 'noise', 'crosshatch'
        colorMode: 'grayscale',    // 'original', 'grayscale', 'duotone', 'custom'
        invert: false,
        pixelRatio: 1,
        primaryColor: '#000000',
        secondaryColor: '#f5f5f5',
        customPalette: ['#000000', '#ffffff'],
        brightness: 0,
        contrast: 1,
        backgroundColor: 'transparent',
        objectFit: 'cover',
        threshold: 0.5,
        animated: true,
        animationSpeed: 0.02,
      };

      // --- Helper functions (same as React component) ---
      const BAYER_MATRIX_4x4 = [
        [0,8,2,10],
        [12,4,14,6],
        [3,11,1,9],
        [15,7,13,5]
      ];
      const BAYER_MATRIX_8x8 = [
        [0,32,8,40,2,34,10,42],
        [48,16,56,24,50,18,58,26],
        [12,44,4,36,14,46,6,38],
        [60,28,52,20,62,30,54,22],
        [3,35,11,43,1,33,9,41],
        [51,19,59,27,49,17,57,25],
        [15,47,7,39,13,45,5,37],
        [63,31,55,23,61,29,53,21]
      ];

      function parseColor(color) {
        if (color.startsWith('#')) {
          const hex = color.slice(1);
          if (hex.length === 3) return [
            parseInt(hex[0]+hex[0],16),
            parseInt(hex[1]+hex[1],16),
            parseInt(hex[2]+hex[2],16)
          ];
          return [
            parseInt(hex.slice(0,2),16),
            parseInt(hex.slice(2,4),16),
            parseInt(hex.slice(4,6),16)
          ];
        }
        const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/i);
        if (match) return [parseInt(match[1]),parseInt(match[2]),parseInt(match[3])];
        return [0,0,0];
      }

      function getLuminance(r,g,b) { return 0.299*r + 0.587*g + 0.114*b; }
      function clamp(v,min,max) { return Math.max(min,Math.min(max,v)); }

      const parsedPrimary = parseColor(config.primaryColor);
      const parsedSecondary = parseColor(config.secondaryColor);
      const parsedCustom = config.customPalette.map(parseColor);

      // --- Setup canvas ---
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      let img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = config.src;

      let imageDataCache = null;
      let imgWidth = 0, imgHeight = 0;
      let animationFrame = null;
      let time = 0;

      function resizeCanvas() {
        const container = canvas.parentElement;
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }

      window.addEventListener('resize', () => {
        resizeCanvas();
        if (imageDataCache) renderFrame(time);
      });

      function renderFrame(t) {
        if (!imageDataCache || canvas.width === 0 || canvas.height === 0) return;

        const w = canvas.width;
        const h = canvas.height;

        ctx.clearRect(0,0,w,h);
        if (config.backgroundColor !== 'transparent') {
          ctx.fillStyle = config.backgroundColor;
          ctx.fillRect(0,0,w,h);
        }

        const sourceData = imageDataCache.data;
        const sw = imgWidth, sh = imgHeight;

        const effectivePixelSize = Math.max(1, Math.floor(config.gridSize * config.pixelRatio));
        const matrixSize = config.gridSize <= 4 ? 4 : 8;
        const bayerMatrix = matrixSize === 4 ? BAYER_MATRIX_4x4 : BAYER_MATRIX_8x8;
        const matrixScale = matrixSize === 4 ? 16 : 64;

        for (let y = 0; y < h; y += effectivePixelSize) {
          for (let x = 0; x < w; x += effectivePixelSize) {
            const srcX = Math.floor((x / w) * sw);
            const srcY = Math.floor((y / h) * sh);
            const srcIdx = (srcY * sw + srcX) * 4;

            let r = sourceData[srcIdx] || 0;
            let g = sourceData[srcIdx+1] || 0;
            let b = sourceData[srcIdx+2] || 0;
            const a = sourceData[srcIdx+3] || 0;
            if (a < 10) continue;

            r = clamp((r-128)*config.contrast + 128 + config.brightness*255, 0, 255);
            g = clamp((g-128)*config.contrast + 128 + config.brightness*255, 0, 255);
            b = clamp((b-128)*config.contrast + 128 + config.brightness*255, 0, 255);

            const lum = getLuminance(r,g,b) / 255;

            // dither threshold
            let thresh;
            const mx = Math.floor(x / config.gridSize) % matrixSize;
            const my = Math.floor(y / config.gridSize) % matrixSize;
            switch (config.ditherMode) {
              case 'bayer':
                thresh = bayerMatrix[my][mx] / matrixScale;
                break;
              case 'halftone': {
                const angle = Math.PI/4;
                const scale = config.gridSize * 2;
                const rotX = x*Math.cos(angle) + y*Math.sin(angle);
                const rotY = -x*Math.sin(angle) + y*Math.cos(angle);
                thresh = (Math.sin(rotX/scale) + Math.sin(rotY/scale) + 2) / 4;
                break;
              }
              case 'noise': {
                const noiseVal = Math.sin(x*12.9898 + y*78.233 + t*100) * 43758.5453;
                thresh = noiseVal - Math.floor(noiseVal);
                break;
              }
              case 'crosshatch': {
                const line1 = (x + y) % (config.gridSize*2) < config.gridSize ? 1 : 0;
                const line2 = (x - y + config.gridSize*4) % (config.gridSize*2) < config.gridSize ? 1 : 0;
                thresh = (line1 + line2) / 2;
                break;
              }
              default: thresh = bayerMatrix[my][mx] / matrixScale;
            }
            thresh = thresh * (1 - config.threshold) + config.threshold * 0.5;

            // determine output color
            let outR, outG, outB;
            switch (config.colorMode) {
              case 'grayscale':
                if (lum < thresh) { outR=0; outG=0; outB=0; }
                else { outR=255; outG=255; outB=255; }
                break;
              case 'duotone':
                if (lum < thresh) { outR=parsedPrimary[0]; outG=parsedPrimary[1]; outB=parsedPrimary[2]; }
                else { outR=parsedSecondary[0]; outG=parsedSecondary[1]; outB=parsedSecondary[2]; }
                break;
              case 'custom':
                if (parsedCustom.length === 2) {
                  if (lum < thresh) { outR=parsedCustom[0][0]; outG=parsedCustom[0][1]; outB=parsedCustom[0][2]; }
                  else { outR=parsedCustom[1][0]; outG=parsedCustom[1][1]; outB=parsedCustom[1][2]; }
                } else {
                  const adjLum = lum + (thresh - 0.5) * 0.5;
                  const idx = Math.floor(clamp(adjLum,0,1) * (parsedCustom.length-1));
                  outR = parsedCustom[idx][0];
                  outG = parsedCustom[idx][1];
                  outB = parsedCustom[idx][2];
                }
                break;
              case 'original':
              default: {
                const ditherAmt = thresh - 0.5;
                const adjR = clamp(r + ditherAmt*64, 0, 255);
                const adjG = clamp(g + ditherAmt*64, 0, 255);
                const adjB = clamp(b + ditherAmt*64, 0, 255);
                const levels = 4;
                outR = Math.round(adjR / (255/levels)) * (255/levels);
                outG = Math.round(adjG / (255/levels)) * (255/levels);
                outB = Math.round(adjB / (255/levels)) * (255/levels);
                break;
              }
            }

            if (config.invert) {
              outR = 255 - outR;
              outG = 255 - outG;
              outB = 255 - outB;
            }

            ctx.fillStyle = `rgb(${outR},${outG},${outB})`;
            ctx.fillRect(x, y, effectivePixelSize, effectivePixelSize);
          }
        }
      }

      img.onload = () => {
        imgWidth = img.naturalWidth;
        imgHeight = img.naturalHeight;

        // draw image to offscreen canvas to get pixel data
        const offCanvas = document.createElement('canvas');
        offCanvas.width = imgWidth;
        offCanvas.height = imgHeight;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(img, 0, 0, imgWidth, imgHeight);
        try {
          imageDataCache = offCtx.getImageData(0, 0, imgWidth, imgHeight);
        } catch(e) {
          console.error('CORS error?');
          return;
        }

        resizeCanvas();
        const animate = () => {
          if (config.animated) {
            time += config.animationSpeed;
          }
          renderFrame(time);
          animationFrame = requestAnimationFrame(animate);
        };
        animate();
      };

      img.onerror = () => console.error('Failed to load image');

      // Connect radio buttons for demo (optional)
      const modeRadios = document.querySelectorAll('input[name="ditherMode"]');
      modeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          config.ditherMode = e.target.value;
        });
      });
      const animCheck = document.getElementById('animatedCheck');
      if (animCheck) {
        animCheck.addEventListener('change', (e) => {
          config.animated = e.target.checked;
        });
      }
    })();
  })();
</script>
{% endblock %}